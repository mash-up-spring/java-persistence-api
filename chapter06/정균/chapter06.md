# `6장: 다양한 연관관계 매핑`

엔티티의 연관관계를 매핑할 때는 아래의 3가지를 고려해야 합니다. 

- 다중성
- 단방향, 양방향
- 연관관계의 주인

<br>

먼저 연관관계가 있는 두 엔티티가 `일대일 관계`인지 `일대다 관계`인지 다중성을 고려해야 합니다.

<br> <br>

## `다중성`

- 다대일(@ManyToOne)
- 일대다(@OneToMany)
- 일대일(@OneToOne)
- 다대다(@ManyToMany)

<br>

다대다는 실무에서 거의 사용하지 않는다고 합니다. (사용하면 안되는 것이기도 합니다.)

<br> <br>

## `단방향, 양방향`

### 테이블

외래 키 하나로 양쪽 조인이 가능합니다. (그래서 방향이라는 개념이 없습니다.)

<br>

### 객체

참조용 필드가 있는 쪽으로만 참조 가능합니다. 한쪽만 참조하면 단방향이라고 합니다. 

<br> 

### 연관관계의 주인

JPA는 두 객체 연관관계 중 하나를 정해서 데이터베이스 외래 키를 관리하는데 이것을 `연관관계의 주인`이라고 합니다. `주인이 아닌 방향은 외래 키를 변경할 수 없고 읽기만 가능합니다.`
연관관계의 주인이 아니면 mappedBy 속성을 사용하고 연관관계의 주인 필드 이름을 값으로 입력해야 합니다. 

<br> <br>

## `다대일 단방향`

![스크린샷 2021-08-26 오후 2 09 14](https://user-images.githubusercontent.com/45676906/130904339-6a87f90e-a5a8-4307-ae66-a42612032f10.png)

다대일 관계에서 DB 테이블 관점에서는 `다(Many)` 쪽에 외래키가 존재해야 합니다. 즉, 위의 상황에서는 `Member가 연관관계의 주인`입니다.

<br>

![스크린샷 2021-08-26 오후 2 11 03](https://user-images.githubusercontent.com/45676906/130904509-c7280e63-6fec-406a-9660-5b67458f25c4.png)

위와 같이 `Member(N): Team(1)`의 관계이기 때문에 Member의 입장에서는 `ManyToOne` 어노테이션을 사용한 것입니다. 

<br>

![스크린샷 2021-08-26 오후 2 12 39](https://user-images.githubusercontent.com/45676906/130904651-3e720e40-811c-4d1d-abaf-8c55e1f15382.png)

그리고 만약에 `양방향 연관 관계`가 필요하다면 위와 같이 Team->Member로 참조도 만들 수 있습니다. Team은 연관관계의 주인이 아니기 때문에 `읽기 전용인 mappedBy`를 사용해서 해야 합니다. 그리고 관례로 바로 `new ArrayList<>()`를 생성해서 사용합니다. 

<br> <br>

## `일대다 단방향`

<img width="1033" alt="스크린샷 2021-08-26 오후 2 14 46" src="https://user-images.githubusercontent.com/45676906/130904829-ea543357-286d-4550-acd3-c4f586ddbcf4.png">

위와 같은 모델로 가능은 하지만 `권장하지 않는 방법`입니다. 위의 모델을 보면 Team에서만 Member를 가지고 있는 것을 볼 수 있습니다. 객체 입장에서는 이렇게 설계가 나올 수도 있지만 테이블 입장에서는 무조건 `다(Many)` 쪽에 외래키를 가지고 있어야 합니다.

이럴 때 문제점은 `Team의 List<Members> 값을 바꿨을 때 Team 테이블이 아니라 Member 테이블을 바꿔야 한다는` 점이 존재합니다. 

<br>

![스크린샷 2021-08-26 오후 2 17 58](https://user-images.githubusercontent.com/45676906/130905140-c3e23830-9801-4b3c-9994-e14c4384cba7.png)

Member 엔티티를 보면 아까 보았던 `ManyToOne`, `JoinColumn` 어노테이션이 존재하지 않는 것을 볼 수 있습니다. 

<br>

![스크린샷 2021-08-26 오후 2 19 40](https://user-images.githubusercontent.com/45676906/130905306-0d6379af-80a4-47ea-9f49-f24654051091.png)

그리고 Team 엔티티는 위와 같이 정의해서 사용할 수 있습니다. 

<br>

![스크린샷 2021-08-26 오후 2 23 30](https://user-images.githubusercontent.com/45676906/130905647-895eb4dc-e378-4fc4-a45d-242e4faedb04.png)

그리고 간단하게 Member와 Team을 저장하는 코드를 작성해보았는데요. 이번에는 Team이 연관관계의 주인이기 때문에 Team을 통해서 Member를 저장하고 있는 코드를 볼 수 있는데요. 뭔가 테이블 관점에서는 외래키가 Member에 존재하지만 객체 관점에서는 Team을 통해서 Member를 저장하고 있기 때문에 뭔가 약간 애매하다는 느낌을 받을 수 있습니다. 

<br>

![스크린샷 2021-08-26 오후 2 25 11](https://user-images.githubusercontent.com/45676906/130905806-79c60708-291d-497d-993d-8fc05073727b.png)

실행을 하고 출력되는 쿼리를 보니 INSERT 쿼리 2번은 제대로 실행이 되었지만, UPDATE 쿼리도 한번 더 실행된 것을 볼 수 있습니다. 이게 위에서 말했던 것처럼 `테이블 관점에서는 외래키가 Member 테이블에 존재하는데 객체 관점에서는 Team이 연관관계의 주인이기 때문에 JPA가 UPDATE 쿼리를 한번 더 실행하게 된 것`입니다.

이렇게 UPDATE 쿼리가 한번 더 실행된다는 것도 단점이지만 더 큰 단점은 `지금은 간단한 객체 관계이기 때문에 덜 헷갈릴 수 있지만 복잡한 객체 관계 사이에서는 상당히 혼란을 일으킬 수 있습니다. 그렇기 떄문에 이러한 모델은 권장하지 않습니다.` 그래서 이러한 모델보다는 `다대일 관계`를 하고 필요하다면 양방향 관계를 추가해서 사용하는 것이 좋습니다. 

<br> <br>

## `일대일 관계`

일대일 관계는 그 반대도 일대일 관계입니다. 테이블 관계에서 일대일, 다대일은 항상 다(Many) 쪽이 외래 키를 가집니다. 반면에 일대일 관계는 주 테이블이나 대상 테이블 둘 중 어느 곳이나 외래 키를 가질 수 있습니다. 
따라서 일대일 관계는 주 테이블이나 대상 테이블 중에 누가 외래 키를 가질지 선택해야 합니다. 

<br> <br>

## `주 테이블에 외래 키`

<img width="990" alt="스크린샷 2021-08-26 오후 2 37 38" src="https://user-images.githubusercontent.com/45676906/130906858-c81f6923-9e6a-4a80-95e3-1a145a25716f.png">

위와 같이 한 사람은 하나의 사물함만 가질 수 있다는 요구사항이 존재합니다. 

<br>

![스크린샷 2021-08-26 오후 3 04 26](https://user-images.githubusercontent.com/45676906/130909584-e49d9276-06e8-4266-9702-993a28409b2a.png)

그래서 위와 같이 `@OneToOne` 어노테이션을 사용해서 설계하면 됩니다. 

<br>

![스크린샷 2021-08-26 오후 3 06 36](https://user-images.githubusercontent.com/45676906/130909777-1e32045a-a655-4d9e-a202-866c778902e6.png)

그리고 만약에 `양방향 매핑`을 하고 싶다면 다른 관계와 똑같이 `연관관계 주인이 아닌 곳에 읽기 전용인 mappedBy 속성을 추가`해주면 됩니다. 

<br> <br>

## `다대다 연관관계`

실무에서는 `다대다 관계`는 사용하지 않는 것을 권장합니다. 관계형 데이터베이스는 테이블 2개로 다대다 관계를 표현할 수 없습니다. 연결 테이블을 추가해서 일대다, 다대일 관계로 풀어내야 합니다. 

<img width="1046" alt="스크린샷 2021-08-26 오후 3 14 52" src="https://user-images.githubusercontent.com/45676906/130910649-9102cd20-9d39-45a2-aec5-328605f1c855.png">

그래서 `회원이 여러개의 상품을 주문할 수 있고 하나의 주문도 여러 회원에게 포함될 수 있기 때문에 중간 테이블`이 필요합니다. 

<br> <Br>

## `객체는 컬렉션을 사용해서 다대다 관계 가능`

<img width="1108" alt="스크린샷 2021-08-26 오후 3 16 56" src="https://user-images.githubusercontent.com/45676906/130910915-2447b552-f6e4-405a-b53e-dc65364fb99c.png">

객체는 다대다 관계를 양쪽다 컬렉션을 사용해서 표현할 수 있지만, 테이블은 중간 테이블이 필요하다는 패러다임의 차이가 존재합니다. 

<br>

![스크린샷 2021-08-26 오후 3 20 55](https://user-images.githubusercontent.com/45676906/130911377-160c8172-ba28-45ec-826a-58de06957d67.png)

<br>

![스크린샷 2021-08-26 오후 3 19 07](https://user-images.githubusercontent.com/45676906/130911199-2664d0c9-82a6-4215-ae79-691e56ca5c87.png)

그래서 먼저 객체에서는 어떻게 `다대다 관계`를 정의할 수 있는지 보겠습니다. 위의 코드를 보면 `@ManyToMany`를 사용한 것을 볼 수 있고, 이번에는 `@JoinColumn`이 아니라 `@JoinTable` 어노테이션을 사용한 것을 볼 수 있습니다. name에는 테이블의 이름을 적어주면 되는데요.
여기서 적은 테이블의 이름이 연결테이블로 생성이 됩니다. 

![스크린샷 2021-08-26 오후 3 22 41](https://user-images.githubusercontent.com/45676906/130911599-34233327-cdb8-4aa4-a518-2bb5d10fc1c0.png)

그리고 실행하면 위와 같이 테이블이 생성되는 것을 확인할 수 있습니다.

<br> <br>

## `다대다 매핑의 한계`

편리해보이지만 실무에서 사용하지 않습니다. 연결 테이블이 단순히 연결만 하고 끝나지 않습니다. 

<img width="1269" alt="스크린샷 2021-08-26 오후 3 25 50" src="https://user-images.githubusercontent.com/45676906/130911923-df2abc57-108f-4599-b6ba-ccda51bbd4d7.png">

위와 같은 상황에서도 `중간 테이블에 어떤 필드가 추가될 수도 있는데 그 때마다 이것을 추가해주는 것이 쉽지 않습니다.` 

<br> <br>

## `다대다 한계 극복, 연결 엔티티 사용`

<img width="1163" alt="스크린샷 2021-08-26 오후 3 27 14" src="https://user-images.githubusercontent.com/45676906/130912081-c15ef2b2-33fa-41fd-b3e3-4451cde64dd2.png">

그래서 이것을 따로 `MemberProduct` 라는 엔티티를 직접 만들어서 중간 테이블과 매핑을 시켜주면 됩니다. 

<br>

![스크린샷 2021-08-26 오후 3 31 24](https://user-images.githubusercontent.com/45676906/130912593-d9759cc9-b7d6-413c-969f-899c77fa7607.png)

먼저 Member와 MemberProduct 관계는 1:N이기 때문에 위와 같은 Member는 연관관계의 주인이 아니기 때문에 읽기 전용이 mappedBy를 설정해주면 됩니다. 

<br>

![스크린샷 2021-08-26 오후 3 32 36](https://user-images.githubusercontent.com/45676906/130912736-eb1407fe-867d-44e9-96eb-308d463d6a1b.png)

마찬가지로 Product도 MemberProduct와 관계가 1:N이기 때문에 Product는 연관관계의 주인이 아니기에 읽기 전용이 mappedBy 설정을 해주면 됩니다. 

<br>

![스크린샷 2021-08-26 오후 3 33 34](https://user-images.githubusercontent.com/45676906/130912854-6f630671-2a3e-4fbd-8350-b3ebbb121e22.png)

그리고 MemberProduct 입장에서는 Member, Product와의 관계가 모두 다(Many)의 입장이기 때문에 연관관계의 주인입니다. 그래서 위와 같이 `@JoinColumn`을 통해서 설정하면 됩니다. 
